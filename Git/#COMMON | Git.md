# COMMON | Git  

## Start Git | Config & SSH  

### Цель и концепция  

Настройка изолированных *Git-окружений* для разных контекстов работы (личные проекты, работа) с автоматическим переключением конфигураций и *SSH-ключей* без ручного вмешательства. Для начала работы устанавливаем *Git*, готовим директории (папки) – личная и рабочая. И для каждой из них настроим свой *Config* и свой *SSH*.

------

### Config

1. Установка *Git*:
   - `brew install git`
     (*Через Homebrew*)  
2. Создаём директории:
   - `mkdir -p ~/Documents/git-repositories/{personal,work}`  
3. Создаём и записываем базовый *(global-default)* – *.gitconfig`*
   - `nano ~/.gitconfig`  
```ini
[user]
   name = AnyName
   email = AnyEmail-personal@example.com
[core]
   editor = nano
[includeIf "gitdir:/Users/UserName/Documents/git-repositories/work/"]
   path = ~/.gitconfig-work
[includeIf "gitdir:/Users/UserName/Documents/git-repositories/personal/"]
   path = ~/.gitconfig-personal
```

4. Создаём отдельные *.config* под каждую директорию
   - `nano ~/.gitconfig-work` and `nano ~/.gitconfig-personal`  
```ini
[user]
   name = AnyName
   email = AnyEmail-work@example.com
```

------

### SSH

1. Создать ключи — *ed25519*:
```bash
# рабочий ключ
ssh-keygen -t ed25519 -C "any@company.com" -f ~/.ssh/id_ed25519_work

# персональный
ssh-keygen -t ed25519 -C "any.personal@example.com" -f ~/.ssh/id_ed25519_personal
```
(где: `-t` – тип ключа | `-С` – комментарий | `-f` – дать своё имя ключу – *path/anyName*)
(так же можно добавить: `-N` – для ввода кодового слова под ключ – *passphrase*)

Добавятся файлы:
- *~/.ssh/id_ed25519_work* и *~/.ssh/id_ed25519_work.pub*
- *~/.ssh/id_ed25519_personal* и *~/.ssh/id_ed25519_personal.pub*

2. Добавляем в _ssh-agent_
(_macOS_ — есть особые опции для _keychain_):

```bash
# старт (если агент ещё не запущен)
eval "$(ssh-agent -s)"

# linux / generic
ssh-add ~/.ssh/id_ed25519_work
ssh-add ~/.ssh/id_ed25519_personal

# macOS (если хочешь хранить в Keychain — разные ключи, macOS используют разные флаги)
ssh-add --apple-use-keychain ~/.ssh/id_ed25519_work 2>/dev/null || ssh-add -K ~/.ssh/id_ed25519_work
ssh-add --apple-use-keychain ~/.ssh/id_ed25519_personal 2>/dev/null || ssh-add -K ~/.ssh/id_ed25519_personal
```

3. Скопировать публичный ключ и добавить в *GitHub/GitLab* (в профиле → *SSH keys*):
```bash
# macOS

pbcopy < ~/.ssh/id_ed25519_work.pub
# затем вставить в GitHub (Work account)

pbcopy < ~/.ssh/id_ed25519_personal.pub
# затем вставить в GitHub (Personal account)
```

4. Для последующей синхронизации удалённого репозитория вносим *ssh-ключ* на *GitHub*/GitLab:  
   1. Заходим в аккаунт *GitHub*  
   2. В настройки / *Settings*  
   3. *SSH* and *GPA* key  
   4. Создаем новые ключи  
   5. Дать описательное имя (например: "*MacBook Pro - Personal*")
   6. В графу ключ вносим данные полученные при помощи команды в терминале либо 3 пункт:
        - `cat ~/.ssh/id_ed25519_personal.pub`
        - `cat ~/.ssh/id_ed25519_work.pub`

4. Прописать *~/.ssh/config* с алиасами (пример для *GitHub* — аналогично для GitLab):
`nano ~/.ssh/config`
```ini
# ~/.ssh/config

Host github-work
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_work
    IdentitiesOnly yes
    AddKeysToAgent yes
    UseKeychain yes

Host github-personal
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_personal
    IdentitiesOnly yes
    AddKeysToAgent yes
    UseKeychain yes
```

------

#### Практическое использование

Варианты правильного вызова команды _git clone_ под разные директории после настройки

```bash
# клонируем рабочий реп в нужную папку
git clone git@github-work:company/repo.git ~/Documents/git-repositories/work/repo

# или для персонального
git clone git@github-personal:username/repo.git ~/Documents/git-repositories/personal/repo

# для существующих репозиториев
cd existing-repo
git remote set-url origin git@github-work:company/repo.git
```

------

#### Проверка и диагностика

##### SSH-соединения

```bash
# Проверка соединения
ssh -T git@github-personal
ssh -T git@github-work

# Ожидаемый ответ:
# Hi username! You've successfully authenticated, but GitHub does not provide shell access.
```

##### Git-конфигурация

```bash
# В любой директории
git config user.email
git config user.name

# Или используйте алиас
git whoami

# Полная конфигурация
git config --list --show-origin
```

##### SSH Agent

```bash
# Проверка запуска агента
ssh-add -l

# Перезапуск при проблемах
killall ssh-agent
eval "$(ssh-agent -s)"
```

------

>[!NOTE]
>**Важно:** Локальная конфигурация (`.git/config`) имеет приоритет над глобальной. Если в проекте уже есть настройки, используйте `git config --local user.email "..."` для переопределения.

------

### Config & SSH | Теория 

**ssh-agent** — это программа-демон, которая хранит приватные SSH-ключи в памяти и по запросу подсовывает их клиенту ssh или другим программам.
_Вместо того чтобы каждый раз вводить парольную фразу для ключа, можно один раз загрузить ключ в агент, и дальше соединения будут использоваться прозрачно._  

**Keychain** — это системное хранилище паролей и сертификатов.
_macOS может запомнить парольную фразу от SSH-ключа в Keychain и автоматически подгружать ключ в ssh-agent при входе в систему._  

------

## Часто используемые команды:  

### git add  

`git add .` – добавляем все изменения в папке в индекс  
`git add ` \<_anyFile_\> — добавляем определённый файл в индекс
(например: `git add main.go`)  


### git branch  

`git branch` — просмотреть все ветки на локальном репозитории  
`git branch -a` — просмотреть все ветки на сервере и на локальном репозитории  
`git branch -d` \<_anyBranch_> — удаляем ветку  
`git branch -m` \<_anyBranch_\> — переименовываем ветку  
`git branch -r` — просмотреть все ветки на сервере  
`git branch` \<_anyBranch_\> — создать новую ветку и именуем   
`git branch -avv` — лучший вариант при просмотре всех веток и их связей, крайних коммитов  
`git branch -vv` — лучший вариант при просмотре локальных веток и их связей  

### —

`git blame` \<_anyFile_\>  — просмотреть изменения в конкретном файле (кто, когда, коммит)  

### git checkout

`git checkout` \<_anyBranch_> — перейти в существующую ветку  
`git checkout -b` \<new-branch-name\> — создать новую ветку и перейти в нее
(где: `-b` — флаг, создающий новую ветку)  
`git checkout` \<commit\> \<_anyFile_\> — возвращаем в директорию конкретную версию конкретного файла  

### —  

`git clone` \<_anyRemoteGit_\> — копируем (клонируем) репозиторий с удалённого сервера  

### git commit

`git commit –m` <commit> **— сохраняем внесенные в индекс изменения с сопровождающим текстом об изменениях**
`git commit --amend --no-edit` **— предварительно добавляем изменения в индекс** `git add .` **который забыли добавить в крайний коммит и отправляем его в крайний коммит без исправления комментария**

`git commit --amend` — **изменяет последний коммит**

### —

`git fetch ` — **обновляем информацию о состоянии удалённого репозитория без слияния в текущую ветку**

`git diff` <file> **— просмотреть изменения в конкретном файле** 

`git init` **— инициализируем Git-репозиторий в директории**
`git init` <name> **— инициализируем и именуем локальный репозиторий**

`git log` **— просматриваем историю репозитория по всем изменениям (коммитам)**
`git log --oneline` **— история коммитов в кратком формате**

`git merge` <branch> **— слияние: вливаем стороннюю ветку в текущую (в которой находимся)**
`git merge --squash` <branch> **слияние (такое же как выше), все коммиты объединяем в один**
`git merge --abort` **— отменяем конфликтное слияние**

`git reset --merge ` **— отменяем слияние**
`git reset --hard` **— отменяем планируемые изменения (не внесённый в коммит)**

`git rm -cached` <file> **— удаляем добавленный в индекс и закоммиченный файл**
`-cached` **— флаг, не удаляем из репозитория, а перестаем его отслеживать** 

`git restore` <file>  **— отменяем изменения не внесённые в индекс и коммит**
`git restore --staged` <file> **— убираем изменения из индекса**

`git pull` **— затянуть изменения с удалённого репозитория**

#### `git push:`

`git push` **— вносим изменения на удалённый репозиторий**
`git push –u origin master` **— при первой внесении изменений на удалённый репозиторий**
`git push --set-upstream origin` <branch> **— отправляем новую ветку на сервер, создаем её**
`git push -u origin` <branch> **— пушим новую ветку на сервер, создаем её**
`--set-upstream` **идентично**  `-u`

#### —

#### `git remote:`

`git remote add origin` <ssh-path> **— связываем локальный с удалённым репозиторием**
`git remote -v` **— просматриваем связи репозиториев** 
`git remote remove origin` **— удаляем связь**
`git remote set-url origin` <ssh-path>

#### —

`git revert --no-commit` <commit-path> — **последовательно отменяем коммиты до нужного коммит, не делая на каждом этапе дополнительного коммита**

#### `git stash`

`git stash` **— отложить изменения те что в индексе и не закомиченные**
`git stash pop` **— вернуть изменения из отложенных**
`git stash list` **— лист с отложенными изменениями**
`git stash drop '0'` **— удаляем определённые изменения, выбранного из листа изменений по номеру** 

`git status` **— проверяем наличия Git-репозитория или наличия изменений в рабочем репозитории**

`git show` **— просматриваем крайний коммит и его содержимое по файлам**
`git show` <cache-commit> **— просматриваем выбранный коммит по хэшу полученного из команды**

`git log` **— список коммитов (кэш, автор, дата, комментарий)**
`git log --oneline` **— список коммитов, короткий вариант**

### Удаление изменение

`git restore` <file> **— удаляем изменения не добавленные в индекс **
`git restore --staged` <file> **— удаляем изменения из индекса но не из директории**

`git reset --hard` **— удаляем все изменения во всех файла** 
`git reset --soft` <commit> **— отменяем предыдущий последний коммит до предпоследнего и изменения вносим в индекс **
`git reset` *HEAD~1* **— работает так же как и софт за исключением добавления в индекс**
`git reset -mixed` **— по умолчанию (вариант выше), **
*HEAD~1* **— альтернативный способ указания на предпоследний коммит** 
`git reset --merge` <commit> **— срезаем изменения слияния до выбранное коммита(как правило предыдущий от коммита слияния)** 

`git clean -f` **— удаляем новые файлы в директорий, которые не отслеживались еще**

`git rm --cached` **— удаляем файл из отслеживания**

------

#### GitHub — pull request

1. Заходим в интерфейс GitHub
2. Жмём на вкладку `Pull request`
3. Далее жмём на `New pull request`
4. И далее выбираем ветки которые хотим слить
   - Стрелка `←` демонстрирует что и куда вливаем
5. Создадим запрос нажав на `Create pull request`
6. Различные вкладки от диалогового окна, заканчивая изменения в файле
7. В первом окне решаем подтвердить или отменить слияние `Merge or Cancel` 
   - В случае, когда решаем слить в основную ветку появятся вариации работы с коммитами во второстипенной ветке

#### Работа в терминале:

***cd `path to the directory`*** - переход в папку по адресу
***cd*** - переход в начальную папку пользователя
***cd ../*** - переход в предыдущую папку (***../../*** - на две папки назад и т.д.)
***cd + tab*** - при данном сочетании и последующем нажатии ***tab***, будут чередоваться наименования папок, возможных для входа.

***ls*** - содержимое текущей папки
***ls –la*** - более подробный вариант просмотра содержимого текущей папки

***mkdir*** - создание папки
***rmdir*** — удаление папки

`[mkdir -p ~/Documents/git-repositories/{work,personal}`

***pwd*** - текущее наше положение в командной строке

***touch*** - создание файлов  

***wip*** - work in process (работа в процессе)

**rm** - remove
**rm –r** - удаление папки 
**`rm –f`** — *удаление файла*

 **`find . -name ".DS_Store" -type f -delete`** — *найти файлы данного разрешения и удалить (только файлы `-type f`*

`cat ~/.gitconfig` 

`echo $HOME`

------

## Основные команды Vim

- `i` **— переходим в текстовый режим**

- `Esc` **— переходим в командный режим**

  *В командном режиме:*

  - `:q` **— выход** 
  - `:q!` **— выход без сохранения**
  - `:wq` **— выход с сохранением**
  - `:help` **— помощь**

------

### Игнорирование

1. Вносим файл в папку с репозиторием с расширением ***.gitignore***
   - ***cd "path to project"***
   - ***touch .gitignore***
2. Вариации игнорирования с объяснением
   - someName.someExtension (*errors.log*) — точечная блокировка файла
   - **.log* — блокировка всех файлов с заданным расширением, * — указывает на любое именование файла
   - *!sampel.log* — исключаем из игнорирования локальный файл 
   - *Logs/* — игнорируем папку целиком 
3. В случаем если мы хотим исключить файл из игнорирования в определенной папке
   1. **logs/*.log** — указываем точечно папку и обязательно указываем расширения для игнорирования
   2. **!logs/pattern.log** — исключаем точечно файл в папке, где файлы с данным разрешением все игнорируются 

### .gitignore

1. Создаем файл с расширением .gitignore в папку с проектом

   - ***cd <Project's way>***
   - ***touch .gitignore***

2. Добавляем точечно файл или расширение файла для его исключения из отслеживания

   - ***in file <.gitingore> wip*** (заходим в IDE или в текстовые редактор и вносим в файл .gitignore файлы)

     - ***errors.log*** 

     либо

     - *** *.log***

3. Для того что бы добавить целую папку с именем logs в исключение

   - ***logs/***

4. Файлы операционной системы 

   - ***.DC_Store***

5. Для исключения всех log файлов кроме конкретного 

   - logs/*.log - исключаем все файлы в папке logs с расширением .log
   - !logs/sample.log - убираем локально файл из исключения для отслеживания

6. ```bash
   # remove any existing files from the repo, skipping over ones not in repo
   find . -name .DS_Store -print0 | xargs -0 git rm --ignore-unmatch
   # specify a global exclusion list
   git config --global core.excludesfile ~/.gitignore
   # adding .DS_Store to that list
   echo .DS_Store >> ~/.gitignore
   ```
   
------

#### Практика | Cases

##### I

Проверяем состояние директории создаем файл, добавим в индекс и попытаемся закоммитеть

- `git status`
- `touch README.md`
- `git add .`
- `git commit -m 'docs: has been added README.md'`
  - Вернет ошибку: ошибка идентификации автора и предложить выполнить следующие команды
    - `git config --global user.mail.email "example.com"`
    - `git config -- global user.name "Youre name"`

------

##### II

Варианты когда мы коммитем без флага `-m` или забываем поставить закрывающий апостроф  

Находимся в терминале в редакторе Vim

- Переходим на латиницу
- Перед началом написания жмем на `i` появится внизу статус `--INSERT--`
- Далее мы хотим сохранить и выйти вбиваем на латинице `:wq`
  - Основные команды Vim
  - `i` **— переходим в текстовый режим**
  - `Esc` **— переходим в командный режим**
    - В командном режиме
      - `:q` **— выход** 
      - `:q!` **— выход без сохранения**
      - `:wq` **— выход с сохранением**
      - `:help` **— помощь**

------

##### III

1-й вариант 

- `git log --oneline` **просматриваем коммиты и находим предпоследний**
- `git reset` <commitPU>
- Можно так же добавить их в индекс и после в стэш
  - `git add.`
  - `git stash`
- Далее возвращаемся в нужную ветку, достаём из стеша, коммитем и отправляем на удалённый репозиторий 
  - `git checkout` <targetBranch>
  - `git stash pop`
  - `git commit -m 'infoType: some changes'`

*вариант когда еще не отправили на удалённый репозиторий коммит*

2-й вариант

Переходим в основную ветку 

- `git checkout master/main`

Произошли изменения добавили в индекс и закоммители

- `git add .` 
- `git commit -m "someChanges"`

Сделали коммит не в той ветке, переходим в ту

- `git checkout` <targetBranch>

Вливаем в нее основную ветку

- `git merge main`

Обратно переходим в ветку мастер и сбрасываем ее

- `git checkout main`
- `git reset --hard HEAD~1` 

------

##### IV

Удалённый репозиторий впереди на несколько коммитов и изменения в этих кометах конфликтующие так же есть изменения в локальной рабочей директории

Перетягиваем изменения из удалённого репозитория

- `git pull`
  - Выдает два конфликта

Слишком много конфликтов и есть вариант убрать эти конфликты в другую ветку

Проверяем статус после перетягивания 

- `git status`
  - Видео конфликтующие изменения красным

Сбрасываем 

- `git reset --hard`
- `git status`

Видим разницу коммитов и понимаем что локальный коммит лучше занести в отдельную ветку

- `git log --oneline` — запомнили нужный коммит
- `git reset HEAD~1`
- `git stash` — отправляем эти изменения в стэш

А хранящие изменения мы убираем в другую ветку

- `git checkout` <someBranches>
- `git stash pop`

Возвращаемся в основную ветку и затягиваем изменения

- `git checkout main`
- `git pull`

------

##### V

- Проблема с авторизацией решается также как и в пункту с `git pull`

- Пустой репозиторий или защищённая ветка
  - Мы имеем свой локальный пустой реп и хотим перетащить 
  - Предварительно надо будет создать файл на удалённом и перетащить его к себе а уже после добавить изменения и запушить на удалённый реп

- Касаемо большой разницы в коммитах, надо предварительно перетянуть все изменения, решить все несоответствия и после запушить свои изменения 

------

##### VI

*Работали над проектом, попросили переключиться на другую задачу. Коммитеть не можем, так как задачу мы не закончили, а принято коммитеть только законченные задачи. При этом не можем переключиться на другую ветку. На такой случай Git предлагает инструмент, который может отложить процесс изменений* 

1. Проверяем в какой ветке находимся (Ситуация: работаем в ветке над текущим заданием)
   - `git status`
2. Внесем изменения находясь в этой ветке, в файле:
   - *work in process*
3. Нам дали новую задачу и необходимо переключиться на неё не потеряв при этом изменений в текущей
   - `git stash`
4. Работаем на другой задачей в этой ветке, добавляем в индекс, коммитем 
   - *work in process*
   - `git add .`
   - `git commit -m 'some information about changing'`
5. Возвращаем изменения которые мы вносили выполняя первую задачу, индексируем, коммитем:
   - `git stash pop`
   - `git add .`
   - `git commit -m 'information about changing'`

------

##### VII

*Внесли изменения, заметили что вносили их не в той ветке, отложили в тайник, переключились на нужную ветку, достали из тайника, индексировали, коммит, запушили*

*Работали над проектом, попросили переключиться на другую задачу. Коммитеть не можем, так как задачу мы не закончили, а принято коммитеть только законченные задачи. При этом не можем переключиться на другую ветку. На такой случай Git предлагает инструмент, который может отложить процесс изменений* 

В задании вам необходимо:

1. сделать минимум четыре коммита и вывести список коммитов;
2. сравнить между собой второй и четвёртый коммит;
3. сравнить один любой файл между первым и третьим коммитом.



1. Ошибка идентификации
   - Изначально не установили наши конфигурации, на которые будет ругаться ***Git***
2. Открытие редактора **Vim**
3. Коммит в неправильную ветку
4. Не получается сделать команду `git pull`
5. Не получается сделать команду `git push`
   - Проблема с авторизацие
   - Защищённой веткой
   - История изменений сильно отличается

------

##### VIII

*Изменения в разных файлах*

1. Вносим изменения на удалённом репозитории при помощи интерфейса хостинга: 
   - *move to the hosting*
   - *doing some changes in a specific file different from the one we will modify on the local repository*
2. Так же вносим изменения в файле на локальном репозитории:
   - *work in process*
3. При вводе команды `git status` на локальном репозитории выдаст информацию, о разницы версий от момента вашего крайнего перетягивания с удалённого. Как результат без учёта возможных изменений от команды, в процессе вашей работы над локальный репозиторием.
4. Так что в случае если мы захотим внести свой комминт на удалённый репозиторий, получим ошибку
   - `git push -u origin main`
   - *! [rejected]*
5. Так что для начала перетягиваем данные из удалённого репозитория 
   - `git pull`
     - Получим работу в текстовом редакторе для корректировки коммита, так как будет слияние коммита удалённого с локальным
6. После того как мы перетянули и слили обе версии, отправляем их на удалённый репозиторий
   - `git push -u origin main`

------

##### IX

### Работа с локальными и удалёнными ветками

| Локальный репозиторий | Удалённый репозиторий | Вариант |
| --------------------- | --------------------- | ------- |
| Есть                  | Нет                   | I       |
| Нет                   | Есть                  | II      |

------

1. Клонируем удалённый репозиторий с разными именованиями в конце 1, 2

   - `git clone 'path to hosting for remote repository' 'some_nameI'`
   - `git clone 'path to hosting for remote repository' 'some_nameII'`

2. Заходим в первую перетянутую директорию и реализуем ***I-вариант*** из таблицы

   1. Создадим новую ветку

      - `git checkout -b 'some_name'` 

        or

      - `git branch 'some_name'`

      - `git checkout 'some_name'`

   2. Внесем любое изменение в файл в этой ветке

      - *work in process*

   3. Проверим наличие изменений, добавим в индекс, и закоммитем

      - `git status`
      - `git add .`
      - `git commit -m 'information about changes'`

   4. Отправляем изменения с новым коммитом и тем самым создаем ветку которая есть только в локальном репозитории

      - `git push -u origin 'some_name'`

        - `-u`

          и

        - `--set-upstream`

   5. Еще раз внесем изменения на локальном репозитории и отправим их на сервер короткой командой

      - *work in process*
      - `git push`

3. Заходим во вторую складированную директорию и реализуем второй вариант ***II-вариант***

   1. Создаем при помощи интерфейса хостинга ветку которой нет в локальном
      - *work in process*
   2. Перетягиваем изменения с сервера на локальный репозиторий
      - `git pull`
        - ***нам придет уведомление***
          - *[new branch] 'some_name' –> origin/some_name
   3. Теперь можем переключиться на эту ветку
      - `git checkout 'some_name'`

------

##### X

1. Вносим изменения в папке проекта на локальном репозитории
   - `work in process`
2. Индексируем полученные изменения 
   - `git add .`
3. Коммитем
   - `git commit -m 'information about changes'`
4. Проверяем статус репозиториев
   - `git status`
     - *Your branch is ahead of 'origin/mastet(or main) by 1 commit'*
5. Если попробуем перетянуть из удалённого, получим:
   - `git pull`
     - Already up to date.
6. Для выравнивания версий передаем закоммиченные данные:
   - `git push`

------

##### XI

#### Локальная версия < удалённая версия

*Начали работать над своим заданием, версия до начала были равны, кто то внес изменения в проект и обновил удалённый репозиторий*

1. Вносим изменения при помощи интерфейса хостинга, коммитем.
   - *github or gitlab*
   - *some changes*
2. В случаем когда версия удалённого выше локальной. Команда `git status` не покажет разницы в версиях
   - *Nothing to commit, working tree clean*
3. Так что при работе с командными проектами, в начале рабочего процесса перетягиваем изменения и так же после работы над заданием перед тем как запушить, так же перетягиваем изменения:
   - `git pull`

------

##### XII

*Изменения в разных файлах*

1. Вносим изменения на удалённом репозитории при помощи интерфейса хостинга: 
   - *move to the hosting*
   - *doing some changes in a specific file different from the one we will modify on the local repository*
2. Так же вносим изменения в файле на локальном репозитории:
   - *work in process*
3. При вводе команды `git status` на локальном репозитории выдаст информацию, о разницы версий от момента вашего крайнего перетягивания с удалённого. Как результат без учёта возможных изменений от команды, в процессе вашей работы над локальный репозиторием.
4. Так что в случае если мы захотим внести свой комминт на удалённый репозиторий, получим ошибку
   - `git push -u origin main`
   - *! [rejected]*
5. Так что для начала перетягиваем данные из удалённого репозитория 
   - `git pull`
     - Получим работу в текстовом редакторе для корректировки коммита, так как будет слияние коммита удалённого с локальным
6. После того как мы перетянули и слили обе версии, отправляем их на удалённый репозиторий
   - `git push -u origin main`

------
#### Сложные:

##### I

*Изменения в одних и тех же файлах и строках*

1. Вносим изменения в файле удалённого и локального репозиториях
   - `work in process`
2. Пробуем затянуть изменения из удалённого репозитория
   - `git pull`
     
     - Получаем ошибку: 
     
       *CONFLICT (content): Merge conflict in "file.txt"*
       *Automatic merge failed; fix conflicts and the commit the result.*
3. Открываем данный файл в **IDE Microsoft Visual Code**
   - *Вручную корректируем конечный результат отталкивая от результатов конфликтующих файлов*
4. Далее вносим финальный результат в индекс и коммитем:
   - `git add .`
   - `git commit -m 'some changes in particular files'`
5. Отправляем коммит на сервер (удалённый репозиторий):
   - `got push -u origin main` or `git push -u origin HEAD: main`



##### II

1. Зайдем в директорию с репозиторием, посмотрим текущую ветку и статус 

   - `git status`

2. Создадим новую ветку и перейдем в неё

   - `git checkout -b "name_new_branch"`

     or

   - `git branch 'name_new_branch'`

   - `git checkout 'name_new_branch'`

3. Внесём изменения в новую ветку, индекс-коммит

   - wip
   - `git add. `
   - `git commit -m 'info'`

4. Переходим в основную ветку и так же вносим в тех же файла и местах изменения (конфликтные изменения)

   - `git checkout main`
   - wip
   - `git add .`
   - `git commit -m 'info abt change'`

5. Слияние в основную ветку вливаем из сторонней

   - `git merge "some_antother_branch"`

6. Добавляем в индекс, коммитем, отправляем на сервер

   - `git add .`
   - `git commit -m 'merge master/main_branch <- some_another_branch'`
   - `git push`
