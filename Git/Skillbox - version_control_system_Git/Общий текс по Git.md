## Общий текст по Git

### Часто используемые команды:

`git add .` **— добавляем все изменения в папке в индекс**
`git add 'Name'` **— добавляем определенный файл в индекс** 

#### `git branch`:

`git branch` **— просмотреть все ветки на локальном репозитории**
`git branch -a` **— просмотреть все ветки на сервере и на локальном репозитории**
`git branch -r` **— просмотреть все ветки на сервере**
`git branch 'Name'` **— создать новую ветку с именем *'Name'***
`git branch -avv` **— лучший вариант при просмотре всех веток и их связей, крайних коммитов** 
`git branch -vv` **— лучший вариант при просмотре локальных веток и их связей**

`git checkout 'existing_branch_name'` **— перейти в существующую ветку**
`git checkout -b 'Some_Name'` **— создать новую ветку и перейти в нее**

***git clone*** - копируем (клон) репозиторий с удалённого сервера

***git commit –m 'comment'*** - сохраняем внесенные в индекс изменения с сопровождающим текстом об изменениях

***git init*** - инициализируем - создаем Git-репозиторий 
***git init `"name git-repository"`***

***git log*** - просматриваем историю репозитория по всем изменениям (коммитам)
***git log ––oneline*** - история коммитов в кратком формате

`git merge 'name_another_branch'` **— слияние: вливаем стороннюю ветку в текущую**  
`git merge --squash 'name_another_branch'`
`git reset --merge`

`git pull` - затянуть изменения с удалённого репозитория

#### `git push:`

***git push*** - вносим изменения на удалённый репозиторий 
***git push –u origin master*** - при первой внесении изменений на удалённый репозиторий
`git push --set-upstream origin 'some_name'` - пушим новую в ветку на сервер, (создаем ее)
`git push -u origin 'some_name'` - флаг `--set-upstream` идентично  `-u`

#### `git remote:`

`git remote add origin 'ssh-pa'` - связываем локальный с удалённым репозиторием
***git remote -v*** - просматриваем связи репозиториев 
***git remote remove origin*** - удаляем связь
***git remote set-url origin*** `"path to the remote git-repository on hosting"`

`git stash` - отложить изменения те что в индексе и нет (не закомиченные)
`git stash pop` - вернуть изменения из отложенных
`git stash list` - лист с отложенными изменениями
`git stash drop '0'` - удаляем определённые изменения, выбранного из листа изменений по номеру 

***git status*** - проверяем наличия Git-репозитория или наличия изменений в рабочем репозитории

***git show*** - просматриваем крайний коммит и его содержимое по файлам
***git show "хэшКоммита"*** - просматриваем выбранный коммит по хэшу полученного из команды ***git log*** или ***git log —oneline*** 

------

#### Прочее/Работа в терминале:

***cd `path to the directory`*** - переход в папку по адресу
***cd*** - переход в начальную папку пользователя
***cd ../*** - переход в предыдущую папку (***../../*** - на две папки назад и т.д.)
***cd + tab*** - при данном сочетании и последующем нажатии ***tab***, будут чередоваться наименования папок, возможных для входа.

***ls*** - содержимое текущей папки
***ls –la*** - более подробный вариант просмотра содержимого текущей папки

***mkdir*** - создание папки

***pwd*** - текущее наше положение в командной строке

***touch*** - создание файлов  

***wip*** - work in process (работа в процессе)

**rm** - remove
**rm –r** - удаление папки 
**`rm –f`** — *удаление файла*

 **`find . -name ".DS_Store" -type f -delete`** — *найти файлы данного разрешения и удалить (только файлы `-type f`*

------

### Ситуации:

#### Локальная версия > удалённая версия

1. Вносим изменения в папке проекта на локальном репозитории
   - `work in process`
2. Индексируем полученные изменения 
   - `git add .`
3. Коммитем
   - `git commit -m 'information about changes'`
4. Проверяем статус репозиториев
   - `git status`
     - *Your branch is ahead of 'origin/mastet(or main) by 1 commit'*
5. Если попробуем перетянуть из удалённого, получим:
   - `git pull`
     - Already up to date.
6. Для выравнивания версий передаем закоммиченные данные:
   - `git push`



#### Локальная версия < удалённая версия

*Начали работать над своим заданием, версия до начала были равны, кто то внес изменения в проект и обновил удалённый репозиторий*

1. Вносим изменения при помощи интерфейса хостинга, коммитем.
   - *github or gitlab*
   - *some changes*
2. В случаем когда версия удалённого выше локальной. Команда `git status` не покажет разницы в версиях
   - *Nothing to commit, working tree clean*
3. Так что при работе с командными проектами, в начале рабочего процесса перетягиваем изменения и так же после работы над заданием перед тем как запушить, так же перетягиваем изменения:
   - `git pull`



### Простой конфликт

*Изменения в разных файлах*

1. Вносим изменения на удалённом репозитории при помощи интерфейса хостинга: 
   - *move to the hosting*
   - *doing some changes in a specific file different from the one we will modify on the local repository*
2. Так же вносим изменения в файле на локальном репозитории:
   - *work in process*
3. При вводе команды `git status` на локальном репозитории выдаст информацию, о разницы версий от момента вашего крайнего перетягивания с удалённого. Как результат без учёта возможных изменений от команды, в процессе вашей работы над локальный репозиторием.
4. Так что в случае если мы захотим внести свой комминт на удалённый репозиторий, получим ошибку
   - `git push -u origin main`
   - *! [rejected]*
5. Так что для начала перетягиваем данные из удалённого репозитория 
   - `git pull`
     - Получим работу в текстовом редакторе для корректировки коммита, так как будет слияние коммита удалённого с локальным
6. После того как мы перетянули и слили обе версии, отправляем их на удалённый репозиторий
   - `git push -u origin main`



### Сложный конфликт:



## I

*Изменения в одних и тех же файлах и строках*

1. Вносим изменения в файле удалённого и локального репозиториях
   - *work in process*
2. Пробуем затянуть изменения из удалённого репозитория
   - `git pull`
     - Получаем ошибку: CONFLICT (content): Merge conflict in "file.txt"
       Automatic merge failed; fix conflicts and the commit the result.
3. Открываем данный файл в **IDE Microsoft Visual Code**
   - *Вручную корректируем конечный результат отталкивая от результатов конфликтующих файлов*
4. Далее вносим финальный результат в индекс и коммитем:
   - `git add .`
   - `git commit -m 'some changes in particular files'`
5. Отправляем коммит на сервер (удалённый репозиторий):
   - `got push -u origin main` or `git push -u origin HEAD: main`



## **II**

1. Зайдем в директорию с репозиторием, посмотрим текущую ветку и статус 

   - `git status`

2. Создадим новую ветку и перейдем в неё

   - `git checkout -b "name_new_branch"`

     or

   - `git branch 'name_new_branch'`

   - `git checkout 'name_new_branch'`

3. Внесём изменения в новую ветку, индекс-коммит

   - wip
   - `git add. `
   - `git commit -m 'info'`

4. Переходим в основную ветку и так же вносим в тех же файла и местах изменения (конфликтные изменения)

   - `git checkout main`
   - wip
   - `git add .`
   - `git commit -m 'info abt change'`

5. Слияние в основную ветку вливаем из сторонней

   - `git merge "some_antother_branch"`

6. Добавляем в индекс, коммитем, отправляем на сервер

   - `git add .`
   - `git commit -m 'merge master/main_branch <- some_another_branch'`
   - `git push`

   

### Работа с локальными и удалёнными ветками

| Локальный репозиторий | Удалённый репозиторий | Вариант |
| --------------------- | --------------------- | ------- |
| Есть                  | Нет                   | I       |
| Нет                   | Есть                  | II      |

------

1. Клонируем удалённый репозиторий с разными именованиями в конце 1, 2

   - `git clone 'path to hosting for remote repository' 'some_nameI'`
   - `git clone 'path to hosting for remote repository' 'some_nameII'`

2. Заходим в первую перетянутую директорию и реализуем ***I-вариант*** из таблицы

   1. Создадим новую ветку

      - `git checkout -b 'some_name'` 

        or

      - `git branch 'some_name'`

      - `git checkout 'some_name'`

   2. Внесем любое изменение в файл в этой ветке

      - *work in process*

   3. Проверим наличие изменений, добавим в индекс, и закоммитем

      - `git status`
      - `git add .`
      - `git commit -m 'information about changes'`

   4. Отправляем изменения с новым коммитом и тем самым создаем ветку которая есть только в локальном репозитории

      - `git push -u origin 'some_name'`

        - `-u`

          и

        - `--set-upstream`

   5. Еще раз внесем изменения на локальном репозитории и отправим их на сервер короткой командой

      - *work in process*
      - `git push`

3. Заходим во вторую складированную директорию и реализуем второй вариант ***II-вариант***

   1. Создаем при помощи интерфейса хостинга ветку которой нет в локальном
      - *work in process*
   2. Перетягиваем изменения с сервера на локальный репозиторий
      - `git pull`
        - ***нам придет уведомление***
          - *[new branch] 'some_name' –> origin/some_name
   3. Теперь можем переключиться на эту ветку
      - `git checkout 'some_name'`



#### GitHub — pull request

1. Заходим в интерфейс GitHub
2. Жмём на вкладку `Pull request`
3. Далее жмём на `New pull request`
4. И далее выбираем ветки которые хотим слить
   - Стрелка `←` демонстрирует что и куда вливаем
5. Создадим запрос нажав на `Create pull request`
6. Различные вкладки от диалогового окна, заканчивая изменения в файле
7. В первом окне решаем подтвердить или отменить слияние `Merge or Cancel` 
   - В случае, когда решаем слить в основную ветку появятся вариации работы с коммитами во второстипенной ветке



## Модели:

![Снимок экрана 2024-04-17 в 14.16.42](/Users/mikhailpachshenko/Desktop/Снимок экрана 2024-04-17 в 14.16.42.png)

![Снимок экрана 2024-04-17 в 14.17.01](/Users/mikhailpachshenko/Desktop/Снимок экрана 2024-04-17 в 14.17.01.png)

------

#### Установка Git и конфигурации

1. Убеждаемся, что Git не установлен:
   - ***git ––version***
2. Устанавливаем инструменты разработчика для командной строки или **XCode**
3. Убеждаемся, что Git установлен 
   - ***git ––version***
4. Настраиваем Git:
   - ***git config ––global user.name "NAME"***
   - ***git config ––global user.email "EMAIL"***
5. Проверяем настройки:
   - ***git config ––list***
6. Посмотреть все настройки и где они заданы
   - ***git config ––list ––show–origin***
7. Просмотреть так же настройки 
   - ***cat ~/.gitconfig***
8. Установить отличный от стандартного текстовый редактор
   - ***git config ––global core.editor emacs***
   - ***git config ––global core.editor '/Applications/…. –w'***
     - Примеры для разных редакторов можно посмотреть на этой странице

       - https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git
9. Установить ветку main как ветку по умолчанию
   - `git config --global init.defaultBranch main` 


- Для вывода содержимого файла с расширением в папке-проекта с ***git-репозиторием*** 

  - ***cat .git/config***

- Для удаления информации из ***git*** репозитория об ***user, email***(в случае дублирования или т.п.) есть следующие команды

  - ***git config ––unset user.name*** || ***git config  ––unset user.email***
  - ***git config ––remove–section user***

- Для инициализации псевдонима

  - ***git config ––global alias.c config***

  - ***git c ––list***

    или

  - ***git config ––global alias.c 'config ––global'***

  - ***git c ––list***



*Работали над проектом, попросили переключиться на другую задачу. Коммитеть не можем, так как задачу мы не закончили, а принято коммитеть только законченные задачи. При этом не можем переключиться на другую ветку. На такой случай Git предлагает инструмент, который может отложить процесс изменений* 

------

1. Проверяем в какой ветке находимся (Ситуация: работаем в ветке над текущим заданием)
   - `git status`
2. Внесем изменения находясь в этой ветке, в файле:
   - *work in process*
3. Нам дали новую задачу и необходимо переключиться на неё не потеряв при этом изменений в текущей
   - `git stash`
4. Работаем на другой задачей в этой ветке, добавляем в индекс, коммитем 
   - *work in process*
   - `git add .`
   - `git commit -m 'some information about changing'`
5. Возвращаем изменения которые мы вносили выполняя первую задачу, индексируем, коммитем:
   - `git stash pop`
   - `git add .`
   - `git commit -m 'information about changing'`




------

### Игнорирование

1. Вносим файл в папку с репозиторием с расширением ***.gitignore***
   - ***cd "path to project"***
   - ***touch .gitignore***
2. Вариации игнорирования с объяснением
   - someName.someExtension (*errors.log*) — точечная блокировка файла
   - **.log* — блокировка всех файлов с заданным расширением, * — указывает на любое именование файла
   - *!sampel.log* — исключаем из игнорирования локальный файл 
   - *Logs/* — игнорируем папку целиком 
3. В случаем если мы хотим исключить файл из игнорирования в определенной папке
   1. **logs/*.log** — указываем точечно папку и обязательно указываем расширения для игнорирования
   2. **!logs/pattern.log** — исключаем точечно файл в папке, где файлы с данным разрешением все игнорируются 

### .gitignore

1. Создаем файл с расширением .gitignore в папку с проектом

   - ***cd <Project's way>***
   - ***touch .gitignore***

2. Добавляем точечно файл или расширение файла для его исключения из отслеживания

   - ***in file <.gitingore> wip*** (заходим в IDE или в текстовые редактор и вносим в файл .gitignore файлы)

     - ***errors.log*** 

     либо

     - *** *.log***

3. Для того что бы добавить целую папку с именем logs в исключение

   - ***logs/***

4. Файлы операционной системы 

   - ***.DC_Store***

5. Для исключения всех log файлов кроме конкретного 

   - logs/*.log - исключаем все файлы в папке logs с расширением .log
   - !logs/sample.log - убираем локально файл из исключения для отслеживания

6. ```bash
   # remove any existing files from the repo, skipping over ones not in repo
   find . -name .DS_Store -print0 | xargs -0 git rm --ignore-unmatch
   # specify a global exclusion list
   git config --global core.excludesfile ~/.gitignore
   # adding .DS_Store to that list
   echo .DS_Store >> ~/.gitignore
   ```

------

### Как получить помощь?

Если вам нужно помощь при использовании Git, есть  три основных способа сделать это:

- ***git help команда***
- ***git команда ––help***
- ***man git-команда***

Например:

- ***git help add***
- ***git add ––help***
- ***git add -h***
- ***man git-add***
- ***git help config***
  - *Далее вылезет листалка, в которой можно напечатать*
    - **/ + нужное слово** — для поиска текста
    - ***n и n +*** — для перелистывания совпадений вперед, назад
    - ***q*** — для выхода из листалки 


------

### SSH ключ

Просмотреть наличие ключа в папке пользователя

- ***cd ~/.ssh***
- ***ls -la***

Для создания ssh ключа есть команда ssh-keygen 

- ***ssh-keygen -o***

- или

- ***ssh-keygen -t ed25519 -C "mikhailpachshenko@gmail.com"***

  (ed25519 - схема подписи, рекомендуемая функция защиты)

Для последующей синхронизации удалённого репозитория вносим ssh ключ на GitHub 

1. Заходим в аккаунт GitHub
2. В настройки
3. SSH and GPA key
4. Создаем новый ключ
5. Именуем 
6. В графу ключ вносим данные полученные при помощи команды в терминале 
   - ***cat ~/.ssh/id_ed25519.pub***
     - Копируем, вставляем в поле на сайте

#### Внимательно 

При клонировании с удалённого репозитория использую графу ssh

- При последующем пуше ***git push -u origin main***
  											 ***git push***

- Потребует ввести пароль от ключа который вы указали на удалённом репозитория для ssh ключа

  ------
  
  

## Теория

***Отслеживаемые файлы*** — это те файлы, которые были в последнем снимке((коммите) состояние проекта). Пока не сделали первый коммит, все файлы не отслеживаемые.

***Не отслеживаемые файлы*** — это всё остальное, любые файлы в рабочем каталоге, которые не входили в последний снимок состояния и не подготовленные к коммиту.f

------

## Вопросы:

- Зачем нужен Git?

- Что такое система контроля версий

- Почему Git, самая популярная система контроля версий

- Что такое репозиторий

- Как сохранять промежуточные версии программного кода

- Как просматривать изменения

- Жизненный цикл файлов в Git

- Отличия работы в командной строке и в средах разработки

  ------
  
  # Для практики
  
  - *Внесли изменения, заметили что вносили их не в той ветке, отложили в тайник, переключились на нужную ветку, достали из тайника, индексировали, коммит, запушили*
  - *Работали над проектом, попросили переключиться на другую задачу. Коммитеть не можем, так как задачу мы не закончили, а принято коммитеть только законченные задачи. При этом не можем переключиться на другую ветку. На такой случай Git предлагает инструмент, который может отложить процесс изменений* 
