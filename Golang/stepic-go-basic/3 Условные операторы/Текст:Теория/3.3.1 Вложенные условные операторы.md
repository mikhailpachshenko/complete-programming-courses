## Вложенные условные операторы

В `if` и/или в `else` можно использовать не только операторы ввода-вывода и присваивания, но и любой другой оператор, в частности, другой оператор `if`. Получаем вложенное ветвление: после одной развилки в ходе исполнения программы появляется другая развилка.

Общий вид следующий:

```go
package main

func main() {
  if условие1 {
    блок кода
  } else {
    if условие2 {
      блок кода
    } else {
      if условие3 {
        блок кода
      }
      ...
    }
  }
}
```



Например, можно вкладывать `if` друг в друга:

```go
if я буду учить программирование каждый день {
  if я даже не сразу пойму условные операторы в этом разделе {
    Я все равно их пойму на другимх примерах дальше;
  }
}
```



### Знак числа

Рассмотрим задачу. Вводится целое число. Нужно определить его знак. Он является либо положительным, либо отрицательным, либо нулем.

Реализуем данную задачу БЕЗ вложенного условного оператора:

```go
package main

import (
	"fmt"
)

func main() {
  var n int
  fmt.Scan(&n)
  if n > 0 {
    fmt.Print("Положительное")
  } if n < 0 {
    fmt.Print("Отрицательное")
  } if n == 0 {
    fmt.Print("Ноль")
  }
}
```



А вот как выглядит данная программа на блок-схеме:

![img](https://ucarecdn.com/a8197b74-be8b-493e-b468-0266e4a98637/)

 Это правильное решение. Но в этом решении есть два минуса:

1. **Происходят лишние вычисления.** Каждое условие проверяется вне зависимости от числа.

   Например, если число положительное, то первое условие будет верным, и программа выведет строку "Положительное". Но программа пойдет дальше проверять следующие условия. К счастью, второе и третье условия будут ложными. Нам на самом деле **повезло, что из 3 условий при любом числе будет верно только одно.** А так бывает не всегда. Такой пример рассмотрим чуть позже.

2. Мы даём другим разработчикам, что исходов ровно 3. Как будто есть еще другие случаи, которые мы не хотим рассматривать. Это плохо. По программе сразу должно быть понятно, какие есть возможные логические ветвления, сколько разных исходов может быть.



А вот как выглядит данная программа на блок-схеме:

![img](https://ucarecdn.com/7fa32e28-f946-4ade-bfec-85f8cf01d060/)

 

Приведем разные входные данные: 

1. Пусть вводится любое положительное число. При таком числе первое условие будет верным, и программа выведет строку "Положительное". Так как условие верно, то значит в `else` не заходим. После `else` никаких команд нет, следовательно, программа завершает свое выполнение

   

   *Заметьте, что лишних проверок других условий нет.*

   

2. Пусть вводится любое отрицательное число. При таком числе первое условие будет ложным. Следовательно, мы зайдем в `else`:

   ```go
   else {
   if n < 0 {
     fmt.Print("Отрицательное")
   } else {
     fmt.Print("Ноль")
   }
   }
   ```

   Выполняем код, который внутри него. Условие `n < 0` будет верным, и программа выведет строку "Отрицательное". Так как условие верно, то значит в `else` не заходим. Внутри и после else в котором находимся, больше команд нет. Следовательно, программа завершает свое выполнение.

   

3. Пусть вводится **ноль**. При таком числе первое условие будет ложным. Следовательно, мы зайдем в `else`:

   ```go
   else {
     if n < 0 {
       fmt.Print("Отрицательное")
     } else {
       fmt.Print("Ноль")
     }
   }
   ```

   Выполняем код, который внутри него . Условие `n < 0` будет ложным. Следовательно, мы зайдем в `else`:

   ```go
   else {
     fmt.Print("Ноль")
   }
   ```

   1. Программа **автоматом** (без лишних проверок на равенство с нулем) выведет строку "Ноль". Внутри и после else в котором находимся, больше команд нет. Следовательно, программа завершает свое выполнение.

      

   **Вывод:**

   Теперь в этой программе нет лишних проверок. Теперь по этой программе легко определить, что есть всего три разных исхода. И что рассмотрев два из них условием `if`, мы автоматически в последнее `else` загоняем третий исход. Очень важно это понять! Прям прочувствовать. Если это не так, задайте все вопросы в комментариях.

    

   Часто начинающие программисты пишут вот так: 

   ```go
   package main
   
   import "fmt"
   
   func main() {
   	var n int
   	fmt.Scan(&n)
   	if n > 0 {
   		fmt.Print("Положительное")
   	} else {
   		if n < 0 {
   			fmt.Print("Отрицательное")
   		} else {
   			if n == 0 { // Добавилось вот это условие
   				fmt.Print("Ноль")
   			}
   		}
   	}
   }
   ```

   Добавляют лишнее условие. Данное условие **лишнее** потому, что если программа зайдет в последнее else, то можно с уверенностью сказать, что число равно нулю. Другого варианта нет. Так как в данное else программа зайдет, когда условия `n > 0` и `n < 0` **ложны**. Следовательно, число равно нулю. Не надо лишний раз писать условие, которое и так будет всегда верным.  



### 5 балльная система

Рассмотрим программу, которая переводит оценку из стобалльной системы в пятибалльную.

Попробуем реализовать данную задачу БЕЗ вложенного условного оператора: 

```go
package main

import "fmt"

func main() {
	var grade int
	fmt.Scan(&grade)
	if grade >= 90 {
		fmt.Print(5)
	}

	if grade >= 80 {
		fmt.Print(4)
	}

	if grade >= 70 {
		fmt.Print(3)
	}

	if grade >= 60 {
		fmt.Print(2)
	}

	if grade >= 0 {
		fmt.Print(1)
	}
}
```

Такое решение неверное. Если запустить программу и ввести, например, число 7575, то на выходе мы получим: 

```
3
2
1
```

 

Все это потому, что теперь одно число может соответствовать нескольким условиям **ОДНОВРЕМЕННО**. Напомню, что в предыдущей разобранной задаче это было не так (там число соответствовало только одному условию). 

Для решения данной проблемы нам помогут вложенные условия: 

```go
package main

import "fmt"

func main() {
    var grade int
    fmt.Scan(&grade)
    if grade >= 90 {
        fmt.Print(5)
    } else {
        if grade >= 80 {
            fmt.Print(4)
        } else {
            if grade >= 70 {
                fmt.Print(3)
            } else {
                if grade >= 60 {
                    fmt.Print(2)
                } else {
                    if grade >= 0 {
                        fmt.Print(1)
                    }
                }
            }
        }
    }
}
```

 

Основная идея в том, что если выполнилось одно условие, то другие условие программа даже проверять НЕ будет. Если теперь запустить программу и ввести, например, число 75, то на выходе мы получим:

```
3
```

 

 

**Примечания:** 

1. Следите за фигурными скобками. У каждой открывающей скобки должна быть закрывающая.
   
2. Не нужно запоминать комбинаций вложенных `if` и `else`. Вам нужно оперировать командами `if-else`. Вы должны знать, как выполняется условный оператор. Рассматривать его как единую команду. И когда у вас внутри блока `if` или `else` еще один условный оператор, то вы его точно таким же правилом будете выполнять.

   Точно также это делается при запуске программы. Исполняющая среда знает правило исполнения команды `if-else`. Где бы не встречалась данная команда, исполняющая среда выполняет условный оператор всегда по одному и тому же правилу. 

