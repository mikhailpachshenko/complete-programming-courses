## 7.1.7 Разбор задачи

По данным натуральным 𝑛 и 𝑘 вычислите значение `𝐶𝑛𝑘=𝑛!/𝑘!⋅(𝑛−𝑘)!` число сочетаний из 𝑛 элементов по 𝑘.

Давайте разбираться. Заметим, что нам нужно посчитать **факториал** 3 раза: 𝑛!,𝑘!,(𝑛−𝑘)!. А далее разделить значение 𝑛! на произведение k*!⋅(*n*−*k*)!.

Давайте решать по порядку. Факториал 𝑛*n* - это произведение чисел от 11 до 𝑛*n*. Чтобы посчитать его, нужно воспользоваться **мультипликатором**. Так и сделаем

```go
var n, k int
fmt.Scan(&n, &k)

factN := 1
for i := 1; i <= n; i++ {
   factN = factN * i
}
```

Теперь в переменной **factN** хранится факториал числа 𝑛*n*. Таким же образом посчитаем факториал и двух других чисел, а именно факториал 𝑘*k* и факториал 𝑛−𝑘*n*−*k*:

```go
factK := 1
for i := 1; i <= k; i++ {
   factK = factK * i
}
nSubtractK := n - k
factNSubtractK := 1
for i = 1; i <= nSubtractK; i++ {
   factNSubtractK = factNSubtractK * i
}
```

Затем, имея значения трех факториалов, нужно вывести

```go
fmt.Println(factN / (factK * factNSubtractK))
```

Таким образом получилась следующая программа:

```go
var n, k int
fmt.Scan(&n, &k)

factN := 1
for i := 1; i <= n; i++ {
   factN = factN * i
}

factK := 1
for i := 1; i <= k; i++ {
   factK = factK * i
}

nSubtractK := n - k
factNSubtractK := 1
for i := 1; i <= nSubtractK; i++ {
   factNSubtractK = factNSubtractK * i
}

fmt.Print(factN / (factK * factNSubtractK))
```

Заметим, что **вычисление факториала** происходит 33 **раза**, меняя **только** значение числа, чей факториал нужно вычислить. Такая программа выглядит **длинной**, **запутанной** и **понять** ее становится **сложнее**.

Давайте напишем **функцию** для вычисления факториала 11 раз, и будем ее использовать 33 раза или сколько угодно раз. Итак, функция вычисления факториала будет принимать **одно целое число**, чей факториал нужно вычислить, и возвращать тоже **целое число**, так как факториал целого числа есть целое число. Функция будет выглядеть следующим образом

```go
func factorial(number int) int {
  fact := 1
  for i := 1; i <= number; i++  {
    fact = fact * i
  }
  return fact
}
```

То есть мы посчитали факториал и вернули его с функции. Теперь давайте ее использовать

```go
package main

import "fmt"

func main() {
    var n, k int
    fmt.Scan(&n, &k)

    factN := factorial(n)
    factK := factorial(k)
    nSubtractK := n - k
    factNSubtractK := factorial(nSubtractK) // можно factorial(n - k), и тогда строчка выше не нужна

    fmt.Println(factN / (factK * factNSubtractK))
}

func factorial(number int) int {
    fact := 1
    for i := 1; i <= number; i++ {
        fact = fact * i
    }
    return fact
}
```

Заметим, насколько **меньше** и **понятней** стала наша программа. За счет **удаления повторного кода**(вычисление факториала), мы сэкономили время, и понять нашу программу теперь легко.