## 6.1 Строки

Буквы, цифры и различные знаки называют **символами**.

**Строка (string)** - это последовательность **символов** заключенная в кавычки. Чтобы создать строковую переменную нужно:

```go
 var str string = "Hello, World!"
```

или

```go
str := "Hello, World!"
```

или

```go
var str string
str = "Hello, World!"
```

Символы помещенные между кавычками называют **строковым литералом.** Набор символов **Hello, World!** из примера выше, это **строковый литерал** 


Чтобы записать в строковую переменную значение, введенное в консоли, нужно воспользоваться следующей инструкцией:

```go
package main

import (
    "fmt"
)

func main() {
    var s string
    fmt.Scan(&s)

    fmt.Println(s)
}
```

 

**Операции со строками**

Над строками определены следующие операции:
 

1. Операция

    

   сложения

   (

   +

   ). Применяется для

    

   сцепления

    

   нескольких строк в одну. По другому это называется

    

   конкатенацией

    

   строк. Например:

   ```go
   var a string = "Hello "
   var b string = "world!"
   
   var c string = a + b  // Hello world!		
   ```

   Для целых и вещественных чисел, при сложении

    

   не

    

   имеет значения в каком порядке идут операнды. При сложении строк

    

   ИМЕЕТ

    

   значение расположение

    

   операндов:

   ```go
   var a string = "Hello "
   var b string = "world!"
   var d string = b + a         // world!Hello 		
   ```

   Итак, сложение работает следующим образом: берется

    

   первый

    

   операнд(

   слева

    

   от знака +) и

    

   сцепляется

    

   ко второму операнду(

   справа

    

   от знака +), следовательно при изменении операнд местами, результирующая строка получается

    

   разной

   .

2. Операции

    

   эквивалентности

   (

   ==, !=

   ). Данные операции проводят

    

   посимвольное

    

   сравнение двух строк на

    

   равенство

   . Результат выполнения операций

    

   всегда

    

   имеет

    

   логический

   (

   bool

   ) тип. Строки считаются

    

   равными

   , если они совпадают по

    

   длине

    

   и содержат одни и те же

    

   символы

    

   на

    

   соответствующих

    

   местах в строке.

   ```go
   a := "HELLO"
   b := "Hello"
   		
   var c bool = a == b  // false
   var d bool = a != b  // true 		
   ```


**Хранение строки в компьютере**

При работе со строками, **Go** использует символы из кодовой таблицы [**Unicode**](https://ru.wikipedia.org/wiki/Юникод). Кодовая таблица **Unicode** включает в себя символы почти всех письменных языков мира. 

Cтрока - это последовательность **byte** (занимает 8 бит). Для того чтобы код символа из **Unicode** преобразовать в байты, **Go** применяет формат кодирования [**UTF8**](https://ru.wikipedia.org/wiki/UTF-8).

Но не все символы из **Unicode** закодированные с помощью **UTF8** занимают 1 байт, а только первые 127, остальные занимают от 2 до 4.

Рассмотрим пример с однобайтовыми символами, которые входят в первые 127 символов кодовой таблицы **Unicode**.

Пусть есть строка **s** следующего вида var `s string = "Basketball"` , в памяти оно выглядит следующим образом

![img](https://ucarecdn.com/bfe3de2a-be99-4b43-8001-6299b1439466/)


Под капотом, строка это последовательность байт и из примера выше каждый символ занимает по одному байту. Все символы в строке **пронумерованы**. **Нумерация** символов в строке начинается **с нуля**. К отдельным символам строки можно обратиться по номеру (**индексу**) данного символа в строке.  Оператор "**[]**" используется для **доступа** к символу строки **по индексу**. Например:

```cs
a := string(s[0])  // 'B'
b := string(s[9])  // 'l'
```

Обратите внимание, для того чтобы получить сам символ нам нужно писать `string(s[0])`. Дело в том что оператор **[]** возвращает не сам символ, а десятичное представление байта символа, он возвращает тип **byte**. Для того чтобы сконвертировать **byte** в **string** необходимо писать `string(byte)`


Если попробовать обратиться к **несуществующему** индексу, то мы получим **ошибку** во время выполнения программы(индекс находился за пределами строки). Например:

```go
c := s[10]  // ошибка. Индекс последнего символа в строке равно 9

d := s[-1]  // ошибка. Индексация начинается с 0

e := s[25]  // ошибка. Такого индекса нет
```

То есть, в данной строке можно обращаться по индексам от 0 до 9. При других значениях индекса, мы получим **ошибку**.

Не трудно догадаться как вычислить индекс **последнего** символа в строке. Так как индексы начинаются с **нуля**, то **последний** индекс в строке можно найти как **количество символов в этой строке минус 1**. Для того чтобы вычислить кол-во символов в строке необходимо использовать функцию `len`. Но есть один нюанс, `len` возвращает кол-во байт в строке, поэтому результат будет верным если все символы в строке будут однобайтовыми. Все однобайтовые символы входят в кодовую таблицу [**ASCII**](https://ru.wikipedia.org/wiki/ASCII), которая является подмножеством кодовой таблицы **Unicode**. В основном это буквы и цифры латинского алфавита.

```go
var s string = "Basketball"
var count int = len(s)      // 10 
fmt.Println("Последний символ равен" + string(s[count - 1]))  // 'l'
```


Если считывать символы со строки можно, то **изменять** символы в строке **НЕЛЬЗЯ**! Например:

```go
var s string = "Basketball"
s[0] = 'b' // ошибка
```


Так как символы в строке **пронумерованы**, мы можем пробежать по строке с помощью **цикла** и обращаться к **каждому** символу. **В переменной цикла** мы будем хранить **индексы** со значениями от **нуля** до **длины** строки **минус один**. Посмотрим пример:

```go
package main

import (
    "fmt"
)

func main() {
    s := "PROGo"
    countChar := len(s)

    for index := 0; index < countChar; index++ {
        fmt.Println(string(s[index]))
    }
}
```


Теперь мы умеем проходить по строке и получать каждый символ в строке. Но это будет работать корректно только для однобайтовых символов. C многобайтовыми символами мы познакомимся в следующем разделе, когда будет изучать тип **rune**

Давайте посчитаем в слове **количество** заглавных букв 'A':

```go
package main

import (
    "fmt"
)

func main() {
    var s string
    fmt.Scan(&s)
    countChar := len(s)

    countA := 0
    for index := 0; index < countChar; index++ {
        if s[index] == 'A' {
            countA++
        }
    }

    fmt.Println(countA)
}
```